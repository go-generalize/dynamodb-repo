// THIS FILE IS A GENERATED CODE. DO NOT EDIT
package {{ .PackageName }}

import (
	"context"
	"fmt"
	"reflect"
{{- range .ImportList }}
	"{{ .Name }}"
{{- end }}

{{- if and (eq .SliceExist true) (eq .EnableIndexes false) }}
	"github.com/go-utils/dedupe"
{{- end }}
{{- if eq .EnableIndexes true }}
	"github.com/knightso/xian"
{{- end }}
	"github.com/guregu/dynamo"
	"golang.org/x/xerrors"
)
{{ $generate := "go:generate" }}
//{{ $generate }} mockgen -source {{ .GeneratedFileName }}.go -destination mock_{{ .GeneratedFileName }}/mock_{{ .GeneratedFileName }}.go

type {{ .RepositoryInterfaceName }} interface {
	// Single
	Get(ctx context.Context, {{ .HashKeyValueName }} {{ .HashKeyFieldType }}{{ RangeKeyArgCheck }}) (*{{ .StructName }}, error)
	Insert(ctx context.Context, subject *{{ .StructName }}) error
	Update(ctx context.Context, subject *{{ .StructName }}) error
	ForceUpdate(ctx context.Context, subject *{{ .StructName }}) error
	Delete(ctx context.Context, subject *{{ .StructName }}) error
	DeleteBy{{ .HashKeyFieldName }}(ctx context.Context, {{ .HashKeyValueName }} {{ .HashKeyFieldType }}) error
	// Multiple
	GetMulti(ctx context.Context, {{ RangeKeyArgCheckGetMulti }}) ([]*{{ .StructName }}, error)
	InsertMulti(ctx context.Context, subjects []*{{ .StructName }}) error
	UpdateMulti(ctx context.Context, subjects []*{{ .StructName }}) error
	DeleteMulti(ctx context.Context, subjects []*{{ .StructName }}) error
	DeleteMultiBy{{ .HashKeyFieldName }}s(ctx context.Context, {{ .HashKeyValueName }}s []{{ .HashKeyFieldType }}) error
	// List
	List(ctx context.Context, req *{{ .StructName }}ListReq, q *dynamo.Scan) ([]*{{ .StructName }}, error)
	// misc
	GetTable() dynamo.Table
	GetTableName() string
}

type {{ .RepositoryStructName }} struct {
	db    *dynamo.DB
	table dynamo.Table
}

// New{{ .RepositoryInterfaceName }} constructor
func New{{ .RepositoryInterfaceName }}(db *dynamo.DB) {{ .RepositoryInterfaceName }} {
	return &{{ .RepositoryStructName }}{
		db:    db,
		table: db.Table("{{ .StructName }}"),
	}
}

// GetTable dynamo.Table getter
func (repo *{{ .RepositoryStructName }}) GetTable() dynamo.Table {
	return repo.table
}

// GetTableName TableName getter
func (repo *{{ .RepositoryStructName }}) GetTableName() string {
	return repo.table.Name()
}

// HasArg HasKeyのペアを返す
func (repo *{{ .RepositoryStructName }}) hashPair(subject *{{ .StructName }}) (string, string) {
	return "'{{ .HashKeyFieldName }}'", fmt.Sprint(subject.{{ .HashKeyFieldName }})
}

{{- if eq .EnableIndexes true }}
// saveIndexes 拡張フィルタを保存する
func (repo *{{ .RepositoryStructName }}) saveIndexes(subjects ...*{{ .StructName }}) error {
	for _, subject := range subjects {
		idx := xian.NewIndexes({{ .StructName }}IndexesConfig)
{{- range $fi := .FieldInfos }}
{{- $PrefixIsSlice := HasPrefixSlice $fi.FieldType}}
{{- range $idx := $fi.Indexes }}
{{- if or (eq $fi.FieldType "bool") (eq $fi.FieldType "int" ) (eq $fi.FieldType "int64" ) (eq $fi.FieldType "float64" ) }}
		idx.{{ $idx.Method }}({{ $idx.ConstName }}, subject.{{ $fi.Field }})
{{- else if eq $fi.FieldType "string" }}
{{- if eq $idx.Method "AddPrefix" }}
		idx.{{ $idx.Method }}es({{ $idx.ConstName }}, subject.{{ $fi.Field }})
{{- else }}
		idx.{{ $idx.Method }}({{ $idx.ConstName }}, subject.{{ $fi.Field }})
{{- end }}
{{- else if eq $fi.FieldType "time.Time" }}
		idx.{{ $idx.Method }}({{ $idx.ConstName }}, subject.{{ $fi.Field }}.Unix())
{{- else if eq $PrefixIsSlice true }}
		idx.{{ $idx.Method }}({{ $idx.ConstName }}, subject.{{ $fi.Field }})
{{- end }}
{{- end }}
{{- end }}
		built, err := idx.Build()
		if err != nil {
			return err
		}
		subject.Indexes = built
	}

	return nil
}

// {{ .StructName }}IndexesConfig {{ .StructName }}用のIndexesConfigを設定する
var {{ .StructName }}IndexesConfig = &xian.Config{
	// IgnoreCase Case insensitive
	// └── 大文字小文字を区別しない
	IgnoreCase:         true,
	// SaveNoFiltersIndex 検索時にフィルタを設定しない場合、この拡張フィルタなし検索用インデックスのEquality Filterが自動で適用される
	// ├── falseで、拡張フィルタのあり・なしの両パターンの検索がある場合、カスタムインデックスを両パターン分用意しておく必要がある
	// └── trueにしておくことでカスタムインデックスを半分に節約することができる
	SaveNoFiltersIndex: true,
}
{{- end }}

// {{ .StructName }}ListReq List取得時に渡すリクエスト
// └─ bool/int(64)|float64 は stringの独自型で渡す(BoolCriteria | NumericCriteria)
type {{ .StructName }}ListReq struct {
{{- range .FieldInfos }}
{{- if eq .FieldType "bool" }}
	{{ .Field }} BoolCriteria
{{- else if or (eq .FieldType "int") (eq .FieldType "int64") (eq .FieldType "float64" ) }}
	{{ .Field }} NumericCriteria
{{- else }}
	{{ .Field }} {{ .FieldType }}
{{- end }}
{{- end }}
}

// List Queryを使用し条件でフィルターをする
//  └─ 第3引数はNOT/OR/IN/RANGEなど、より複雑な条件を適用したいときにつける
//      └─ 基本的にnilを渡せば良い
// BUG(54mch4n) 潜在的なバグがあるかもしれない
func (repo *{{ .RepositoryStructName }}) List(ctx context.Context, req *{{ .StructName }}ListReq, q *dynamo.Scan) ([]*{{ .StructName }}, error) {
	var err error

	if q == nil {
		q = repo.db.Table("{{ .StructName }}").Scan()
	}
{{ $Enable := .EnableIndexes }}
{{- if eq $Enable true }}
	filters := xian.NewFilters({{ .StructName }}IndexesConfig)
{{- end }}
{{- range $fi := .FieldInfos }}
{{- $PrefixIsSlice := HasPrefixSlice $fi.FieldType}}
{{- if eq $fi.FieldType "bool" }}
	if req.{{ $fi.Field }} != "" {
{{- if eq $Enable true }}
{{- range $idx := $fi.Indexes }}
		filters.{{ $idx.Method }}({{ $idx.ConstName }}, req.{{ $fi.Field }})
{{- end }}
{{- else }}
		q = q.Filter("'{{ $fi.DynamoTag }}' = ?", req.{{ $fi.Field }}.Bool())
{{- end }}
	}
{{- else if eq $fi.FieldType "string" }}
	if req.{{ $fi.Field }} != "" {
{{- if eq $Enable true }}
{{- range $idx := $fi.Indexes }}
		filters.{{ $idx.Method }}({{ $idx.ConstName }}, req.{{ $fi.Field }})
{{- end }}
{{- else }}
		q = q.Filter("'{{ $fi.DynamoTag }}' = ?", req.{{ $fi.Field }})
{{- end }}
	}
{{- else if or (eq $fi.FieldType "int") (eq $fi.FieldType "int64") (eq $fi.FieldType "float64" ) }}
	if req.{{ $fi.Field }} != NumericCriteriaEmpty {
{{- if eq $Enable true }}
{{- range $idx := $fi.Indexes }}
		filters.{{ $idx.Method }}({{ $idx.ConstName }}, req.{{ $fi.Field }}.{{ Parse $fi.FieldType }}())
{{- end }}
{{- else }}
		q = q.Filter("'{{ $fi.DynamoTag }}' = ?", req.{{ $fi.Field }}.{{ Parse $fi.FieldType }}())
{{- end }}
	}
{{- else if eq $fi.FieldType "time.Time" }}
	if !req.{{ $fi.Field }}.IsZero() {
{{- if eq $Enable true }}
{{- range $idx := $fi.Indexes }}
		filters.{{ $idx.Method }}({{ $idx.ConstName }}, req.{{ $fi.Field }}.Unix())
{{- end }}
{{- else }}
		q = q.Filter("'{{ $fi.DynamoTag }}' = ?", req.{{ $fi.Field }})
{{- end }}
	}
{{- else if eq $PrefixIsSlice true }}
	if len(req.{{ $fi.Field }}) > 0 {
{{- if eq $Enable true }}
{{- range $idx := $fi.Indexes }}
		filters.{{ $idx.Method }}({{ $idx.ConstName }}, req.{{ $fi.Field }})
{{- end }}
{{- else }}
		dedupe.Do(&req.{{ $fi.Field }})
		for _, x := range req.{{ $fi.Field }} {
			q = q.Filter("'{{ $fi.DynamoTag }}' = ?", x)
		}
{{- end }}
	}
{{- end }}
{{- end }}
{{ if eq $Enable true }}
	built, err := filters.Build()
	if err != nil {
		return nil, err
	}

	for _, f := range built {
		q = q.Filter("contains({{ .FieldInfoForIndexes.DynamoTag }}, ?)", f)
	}
{{- end }}
	subjects := []*{{ .StructName }}{}
	err = q.AllWithContext(ctx, &subjects)

	if err != nil {
		return nil, err
	}

	return subjects, nil
}

// Get 処理中の {{ .StructName }} の取得処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) Get(ctx context.Context, {{ .HashKeyValueName }} {{ .HashKeyFieldType }}{{ RangeKeyArgCheck }}) (*{{ .StructName }}, error) {
	subject := new({{ .StructName }})
	if err := repo.table.Get("'{{ .HashKeyFieldName }}'", {{ .HashKeyValueName }}){{ RangeKeyValueCheck }}.OneWithContext(ctx, &subject); err != nil {
		return nil, err
	}
	return subject, nil
}

// Insert 処理中の {{ .StructName }} の登録処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) Insert(ctx context.Context, subject *{{ .StructName }}) error {
{{- if eq .EnableIndexes true }}
	if err := repo.saveIndexes(subject); err != nil {
		return xerrors.Errorf("error in saveIndexes method: %w", err)
	}
{{- end }}

	return repo.table.Put(subject).RunWithContext(ctx)
}

// Update 処理中の {{ .StructName }} の更新処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) Update(ctx context.Context, subject *{{ .StructName }}) (err error) {
	old, err := repo.Get(ctx, subject.ID{{ RangeKeyDelivery }})
	if err != nil {
		return err
	}
{{- if eq .EnableIndexes true }}
	if err := repo.saveIndexes(subject); err != nil {
		return xerrors.Errorf("error in saveIndexes method: %w", err)
	}
{{- end }}

	if reflect.DeepEqual(old, subject) {
		return xerrors.Errorf("cannot update because there is no difference. Hash: %v", subject.ID)
	}
	q := repo.table.Update(repo.hashPair(subject))
	bv := reflect.Indirect(reflect.ValueOf(old))
	av := reflect.Indirect(reflect.ValueOf(subject))
	for n := 0; n < av.NumField(); n++ {
		f := av.Type().Field(n)
		bf := bv.Index(n)
		af := bv.Index(n)
		path := fmt.Sprintf("'%s'", f.Name)
		if bf.Interface() != af.Interface() {
			switch af.Kind() {
			case reflect.Array, reflect.Slice:
				q = q.SetSet(path, af.Interface())
			default:
				q = q.Set(path, af.Interface())
			}
		}
	}
	return q.RunWithContext(ctx)
}

// ForceUpdate 処理中の {{ .StructName }} の更新処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) ForceUpdate(ctx context.Context, subject *{{ .StructName }}) error {
{{- if eq .EnableIndexes true }}
	if err := repo.saveIndexes(subject); err != nil {
		return xerrors.Errorf("error in saveIndexes method: %w", err)
	}
{{- end }}

	u := repo.table.Update(repo.hashPair(subject)).
{{- range $i, $fi := .FieldInfos }}
		Set("{{ $fi.DynamoTag }}", subject.{{ $fi.Field }}){{ HasColon $i $.FieldInfos }}
{{- end }}
	return u.RunWithContext(ctx)
}

// Delete 処理中の {{ .StructName }} の削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) Delete(ctx context.Context, subject *{{ .StructName }}) error {
	return repo.table.Delete(repo.hashPair(subject)).RunWithContext(ctx)
}

// DeleteBy{{ .HashKeyFieldName }} 処理中の {{ .StructName }} の{{ .HashKeyFieldName }}から削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) DeleteBy{{ .HashKeyFieldName }}(ctx context.Context, {{ .HashKeyValueName }} {{ .HashKeyFieldType }}) error {
	subject := &{{ .StructName }}{ {{- .HashKeyFieldName }}: {{ .HashKeyValueName }}}
	return repo.Delete(ctx, subject)
}

// GetMulti 処理中の {{ .StructName }} の一括取得処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) GetMulti(ctx context.Context, {{ RangeKeyArgCheckGetMulti }}) (subjects []*{{ .StructName }}, err error) {
	for {{ RangeKeyForTerms }} {
		subject, err :=  repo.Get(ctx, {{ RangeKeyForValue }})
		if err != nil {
			return nil,  err
		}
		subjects = append(subjects, subject)
	}
	return
}

// InsertMulti 処理中の {{ .StructName }} の一括挿入処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) InsertMulti(ctx context.Context, subjects []*{{ .StructName }}) error {
	tx := repo.db.WriteTx()
	for _, subject := range subjects {
{{- if eq .EnableIndexes true }}
		if err := repo.saveIndexes(subject); err != nil {
			return xerrors.Errorf("error in saveIndexes method: %w", err)
		}
{{- end }}
		tx.Put(repo.table.Put(subject))
	}
	return tx.RunWithContext(ctx)
}

// UpdateMulti 処理中の {{ .StructName }} の一括更新処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) UpdateMulti(ctx context.Context, subjects []*{{ .StructName }}) error {
	tx := repo.db.WriteTx()
	for _, subject := range subjects {
{{- if eq .EnableIndexes true }}
		if err := repo.saveIndexes(subject); err != nil {
			return xerrors.Errorf("error in saveIndexes method: %w", err)
		}
{{- end }}
		u := repo.table.Update(repo.hashPair(subject)).
{{- if ne .RangeKeyFieldName "" }}
			Range("'{{ .RangeKeyFieldTagName }}'", subject.{{ .RangeKeyFieldName }}).
{{- end }}
{{- range $i, $fi := .FieldInfos }}
			Set("'{{ $fi.DynamoTag }}'", subject.{{ $fi.Field }}){{ HasColon $i $.FieldInfos }}
{{- end }}
		tx.Update(u)
	}
	return tx.RunWithContext(ctx)
}

// DeleteMulti 処理中の {{ .StructName }} の一括削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) DeleteMulti(ctx context.Context, subjects []*{{ .StructName }}) error {
	tx := repo.db.WriteTx()
	for _, subject := range subjects {
		tx.Delete(repo.table.Delete(repo.hashPair(subject)))
	}
	return tx.RunWithContext(ctx)
}

// DeleteMultiBy{{ .HashKeyFieldName }}s 処理中の {{ .StructName }} の{{ .HashKeyFieldName }}群を元に一括削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) DeleteMultiBy{{ .HashKeyFieldName }}s(ctx context.Context, {{ .HashKeyValueName }}s []{{ .HashKeyFieldType }}) error {
	tx := repo.db.WriteTx()
	for _, {{ .HashKeyValueName }} := range {{ .HashKeyValueName }}s {
		subject := &{{ .StructName }}{ {{- .HashKeyFieldName }}: {{ .HashKeyValueName }}}
		tx.Delete(repo.table.Delete(repo.hashPair(subject)))
	}
	return tx.RunWithContext(ctx)
}
