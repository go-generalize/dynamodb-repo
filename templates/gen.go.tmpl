// THIS FILE IS A GENERATED CODE. DO NOT EDIT
package {{ .PackageName }}

import (
	"context"
	"reflect"
{{- if or ( eq .EnableCreateTime true ) ( eq .EnableUpdateTime true )}}
	"time"
{{- end }}
{{- range .ImportList }}
	"{{ .Name }}"
{{- end }}
{{ if or ( eq .EnableCreateTime true ) ( eq .EnableUpdateTime true )}}
	dda "github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
{{- end }}
{{- if eq .AutoGeneration true }}
	"github.com/google/uuid"
{{- end }}
	"github.com/guregu/dynamo"
	"golang.org/x/xerrors"
)
{{ $generate := "go:generate" }}
//{{ $generate }} mockgen -source {{ .GeneratedFileName }}.go -destination mock/mock_{{ .GeneratedFileName }}/mock_{{ .GeneratedFileName }}.go

type {{ .RepositoryInterfaceName }} interface {
	// Single
	Get(ctx context.Context, {{ .HashKeyValueName }} {{ .HashKeyFieldType }}{{ RangeKeyArgCheck }}) (*{{ .StructName }}, error)
	Insert(ctx context.Context, subject *{{ .StructName }}) error
	Update(ctx context.Context, subject *{{ .StructName }}) error
	ForceUpdate(ctx context.Context, subject *{{ .StructName }}) error
	Delete(ctx context.Context, subject *{{ .StructName }}) error
	DeleteBy{{ FuncNameByValue }}(ctx context.Context, {{ .HashKeyValueName }} {{ .HashKeyFieldType }}{{ RangeKeyArgCheck }}) error
	// Multiple
	GetMulti(ctx context.Context, {{ RangeKeyArgCheckPairs }}) ([]*{{ .StructName }}, error)
	InsertMulti(ctx context.Context, subjects []*{{ .StructName }}) error
	UpdateMulti(ctx context.Context, subjects []*{{ .StructName }}) error
	DeleteMulti(ctx context.Context, subjects []*{{ .StructName }}) error
	DeleteMultiBy{{ FuncNameByValue }}s(ctx context.Context, {{ RangeKeyArgCheckPairs }}) error
	// Query
	List(name string, value interface{}) *dynamo.Query
	Scan() *dynamo.Scan
	// misc
	GetTable() dynamo.Table
	GetTableName() string
}

type {{ .RepositoryStructName }} struct {
	db    *dynamo.DB
	table dynamo.Table
}

// New{{ .RepositoryInterfaceName }} constructor
func New{{ .RepositoryInterfaceName }}(db *dynamo.DB) {{ .RepositoryInterfaceName }} {
	return &{{ .RepositoryStructName }}{
		db:    db,
		table: db.Table("{{ .TableName }}"),
	}
}

// GetTable dynamo.Table getter
func (repo *{{ .RepositoryStructName }}) GetTable() dynamo.Table {
	return repo.table
}

// GetTableName TableName getter
func (repo *{{ .RepositoryStructName }}) GetTableName() string {
	return repo.table.Name()
}

// HasArg HasKeyのペアを返す
func (repo *{{ .RepositoryStructName }}) hashPair(subject *{{ .StructName }}) (string, interface{}) {
	return "{{ .HashKeyFieldTagName }}", subject.{{ .HashKeyFieldName }}
}

// List ハッシュキーやGSIを利用した検索を行う
// GSIを利用した場合、ListにはGSIが適用されている属性の名前と値を指定し、必ずIndexでインデックス名を指定する必要がある
func (repo *{{ .RepositoryStructName }}) List(name string, value interface{}) *dynamo.Query {
	return repo.table.Get(name, value)
}

// Scan 検索ができない時テーブル全体もしくはGSI全体に対して検索をかける
// パフォーマンスやコストの観点から可能な限りListを使用する方が望ましい
func (repo *{{ .RepositoryStructName }}) Scan() *dynamo.Scan {
	return repo.table.Scan()
}

// Get 処理中の {{ .StructName }} の取得処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) Get(ctx context.Context, {{ .HashKeyValueName }} {{ .HashKeyFieldType }}{{ RangeKeyArgCheck }}) (*{{ .StructName }}, error) {
	subject := new({{ .StructName }})
	if err := repo.table.Get("{{ .HashKeyFieldTagName }}", {{ .HashKeyValueName }}){{ RangeKeyValueCheckForGet }}.OneWithContext(ctx, &subject); err != nil {
		return nil, xerrors.Errorf("error in Get method: %w", err)
	}
	return subject, nil
}

// Insert 処理中の {{ .StructName }} の登録処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) Insert(ctx context.Context, subject *{{ .StructName }}) error {
{{- if eq .AutoGeneration true }}
	subject.{{ .HashKeyFieldName }} = {{ GenerationKey }}
{{- else }}
{{- if eq .HashKeyFieldType "string" }}
	if subject.{{ .HashKeyFieldName }} == "" {
{{- else }}
	if subject.{{ .HashKeyFieldName }} == 0 {
{{- end }}
		return xerrors.New("{{ .HashKeyFieldName }} is required")
	}
	if _, err := repo.Get(ctx, {{ RangeKeyValueCheckForInsert }}); err == nil {
		return xerrors.Errorf("already exist [hash: %s{{ RangeKeyValueCheckForInsertFmt }}]", {{ RangeKeyValueCheckForInsert }})
	}
{{- end }}
{{- if eq .EnableCreateTime true }}
	subject.{{ .CreateTimeName }} = {{ Now .CreateTimeType }}
{{- end }}
{{- if eq .EnableUpdateTime true }}
	subject.{{ .UpdateTimeName }} = {{ Now .UpdateTimeType }}
{{- end }}
	return repo.table.Put(subject).RunWithContext(ctx)
}

// Update 処理中の {{ .StructName }} の更新処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) Update(ctx context.Context, subject *{{ .StructName }}) (err error) {
	old, err := repo.Get(ctx, subject.{{ .HashKeyFieldName }}{{ RangeKeyDelivery }})
	if err != nil {
		return xerrors.Errorf("error in Get method: %w", err)
	}

	updated := map[string]interface{}{}
{{- $created := .CreateTimeName }}
{{- $updated := .UpdateTimeName }}
{{- range $i, $fi := .FieldInfos }}
{{- if and ( ne $fi.Field $created ) ( ne $fi.Field $updated )}}
	if !reflect.DeepEqual(old.{{$fi.Field}}, subject.{{$fi.Field}}) {
		updated["{{$fi.DynamoTag}}"] = subject.{{$fi.Field}}
	}

{{- end }}
{{- end }}

	if len(updated) == 0 {
		return ErrNoDifference
	}

	q := repo.table.Update(repo.hashPair(subject)){{ RangeKeyValueCheckForDelete }}
	for path, v := range updated {
		q = q.Set(path, v)
	}

{{- if eq .EnableUpdateTime true }}
	q = q.Set("{{ .UpdateTimeDynamoTag }}", {{ Now .UpdateTimeType }})
{{- end }}

	return q.RunWithContext(ctx)
}

// ForceUpdate 処理中の {{ .StructName }} の更新処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) ForceUpdate(ctx context.Context, subject *{{ .StructName }}) error {
	u := repo.table.Update(repo.hashPair(subject)){{ RangeKeyValueCheckForDelete }}.
{{- range $i, $fi := .FieldInfos }}
{{- if and ( ne $fi.Field $created ) ( ne $fi.Field $updated )}}
		Set("{{ $fi.DynamoTag }}", subject.{{ $fi.Field }}){{ HasColon $i $.FieldInfos }}
{{- end }}
{{- end }}
{{- if eq .EnableUpdateTime true }}
		Set("{{ .UpdateTimeDynamoTag }}", {{ Now .UpdateTimeType }})
{{- end }}
	return u.RunWithContext(ctx)
}

// Delete 処理中の {{ .StructName }} の削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) Delete(ctx context.Context, subject *{{ .StructName }}) error {
	return repo.table.Delete(repo.hashPair(subject)){{ RangeKeyValueCheckForDelete }}.RunWithContext(ctx)
}

// DeleteBy{{ .HashKeyFieldName }} 処理中の {{ .StructName }} の{{ .HashKeyFieldName }}から削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) DeleteBy{{ FuncNameByValue }}(ctx context.Context, {{ .HashKeyValueName }} {{ .HashKeyFieldType }}{{ RangeKeyArgCheck }}) error {
	return repo.table.Delete("{{ .HashKeyFieldTagName }}", {{ .HashKeyValueName }}){{ RangeKeyValueCheckForDeletePair }}.RunWithContext(ctx)
}

// GetMulti 処理中の {{ .StructName }} の一括取得処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) GetMulti(ctx context.Context, {{ RangeKeyArgCheckPairs }}) (subjects []*{{ .StructName }}, err error) {
	for {{ RangeKeyForTerms }} {
		subject, err := repo.Get(ctx, {{ RangeKeyForValue }})
		if err != nil {
			return nil, xerrors.Errorf("error in Get method: %w", err)
		}
		subjects = append(subjects, subject)
	}
	return
}

// InsertMulti 処理中の {{ .StructName }} の一括挿入処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) InsertMulti(ctx context.Context, subjects []*{{ .StructName }}) error {
	tx := repo.db.WriteTx()
	for _, subject := range subjects {
{{- if eq .AutoGeneration true }}
		subject.{{ .HashKeyFieldName }} = {{ GenerationKey }}
{{- else }}
{{- if eq .HashKeyFieldType "string" }}
		if subject.{{ .HashKeyFieldName }} == "" {
{{- else }}
		if subject.{{ .HashKeyFieldName }} == 0 {
{{- end }}
			return xerrors.New("{{ .HashKeyFieldName }} is required")
		}
		if _, err := repo.Get(ctx, {{ RangeKeyValueCheckForInsert }}); err == nil {
			return xerrors.Errorf("already exist [hash: %v{{ RangeKeyValueCheckForInsertFmt }}]", {{ RangeKeyValueCheckForInsert }})
		}
{{- end }}
{{- if eq .EnableCreateTime true }}
		subject.{{ .CreateTimeName }} = {{ Now .CreateTimeType }}
{{- end }}
{{- if eq .EnableUpdateTime true }}
		subject.{{ .UpdateTimeName }} = {{ Now .UpdateTimeType }}
{{- end }}
		tx.Put(repo.table.Put(subject))
	}
	return tx.RunWithContext(ctx)
}

// UpdateMulti 処理中の {{ .StructName }} の一括更新処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) UpdateMulti(ctx context.Context, subjects []*{{ .StructName }}) error {
	tx := repo.db.WriteTx()
	for _, subject := range subjects {
		u := repo.table.Update(repo.hashPair(subject)).
{{- if ne .RangeKeyFieldName "" }}
			Range("{{ .RangeKeyFieldTagName }}", subject.{{ .RangeKeyFieldName }}).
{{- end }}
{{- range $i, $fi := .FieldInfos }}
{{- if and ( ne $fi.Field $created ) ( ne $fi.Field $updated )}}
			Set("{{ $fi.DynamoTag }}", subject.{{ $fi.Field }}){{ HasColon $i $.FieldInfos }}
{{- end }}
{{- end }}
{{- if eq .EnableUpdateTime true }}
			Set("{{ .UpdateTimeDynamoTag }}", {{ Now .UpdateTimeType }})
{{- end }}
		tx.Update(u)
	}
	return tx.RunWithContext(ctx)
}

// DeleteMulti 処理中の {{ .StructName }} の一括削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) DeleteMulti(ctx context.Context, subjects []*{{ .StructName }}) error {
	tx := repo.db.WriteTx()
	for _, subject := range subjects {
		tx.Delete(repo.table.Delete(repo.hashPair(subject)){{ RangeKeyValueCheckForDelete }})
	}
	return tx.RunWithContext(ctx)
}

// DeleteMultiBy{{ .HashKeyFieldName }}s 処理中の {{ .StructName }} の{{ .HashKeyFieldName }}群を元に一括削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) DeleteMultiBy{{ FuncNameByValue }}s(ctx context.Context, {{ RangeKeyArgCheckPairs }}) error {
	tx := repo.db.WriteTx()
	for {{ RangeKeyForTerms }} {
		tx.Delete(repo.table.Delete{{ RangeKeyForDeleteMultiByPairs }})
	}
	return tx.RunWithContext(ctx)
}
