// THIS FILE IS A GENERATED CODE. DO NOT EDIT
package {{ .PackageName }}

import (
	"context"
	"fmt"
	"reflect"
{{- range .ImportList }}
	// "{{ .Name }}"
{{- end }}

{{- if and (eq .SliceExist true) (eq .EnableIndexes false) }}
	// "github.com/go-utils/dedupe"
{{- end }}
{{- if eq .EnableIndexes true }}
	"github.com/knightso/xian"
{{- end }}
	"github.com/guregu/dynamo"
	"golang.org/x/xerrors"
)
{{ $generate := "go:generate" }}
//{{ $generate }} mockgen -source {{ .GeneratedFileName }}.go -destination mock_{{ .GeneratedFileName }}/mock_{{ .GeneratedFileName }}.go

type {{ .RepositoryInterfaceName }} interface {
	// Single
	Get(ctx context.Context, {{ .HashKeyValueName }} {{ .HashKeyFieldType }}{{ RangeKeyArgCheck }}) (*{{ .StructName }}, error)
	Insert(ctx context.Context, subject *{{ .StructName }}) error
	Update(ctx context.Context, subject *{{ .StructName }}) error
	ForceUpdate(ctx context.Context, subject *{{ .StructName }}) error
	Delete(ctx context.Context, subject *{{ .StructName }}) error
	DeleteBy{{ FuncNameByValue }}(ctx context.Context, {{ .HashKeyValueName }} {{ .HashKeyFieldType }}{{ RangeKeyArgCheck }}) error
	// Multiple
	GetMulti(ctx context.Context, {{ RangeKeyArgCheckPairs }}) ([]*{{ .StructName }}, error)
	InsertMulti(ctx context.Context, subjects []*{{ .StructName }}) error
	UpdateMulti(ctx context.Context, subjects []*{{ .StructName }}) error
	DeleteMulti(ctx context.Context, subjects []*{{ .StructName }}) error
	DeleteMultiBy{{ FuncNameByValue }}s(ctx context.Context, {{ RangeKeyArgCheckPairs }}) error
	// List
	// TODO List(ctx context.Context, req *{{ .StructName }}ListReq) ([]*{{ .StructName }}, error)
	// misc
	GetTable() dynamo.Table
	GetTableName() string
}

type {{ .RepositoryStructName }} struct {
	db    *dynamo.DB
	table dynamo.Table
}

// New{{ .RepositoryInterfaceName }} constructor
func New{{ .RepositoryInterfaceName }}(db *dynamo.DB) {{ .RepositoryInterfaceName }} {
	return &{{ .RepositoryStructName }}{
		db:    db,
		table: db.Table("{{ .StructName }}"),
	}
}

// GetTable dynamo.Table getter
func (repo *{{ .RepositoryStructName }}) GetTable() dynamo.Table {
	return repo.table
}

// GetTableName TableName getter
func (repo *{{ .RepositoryStructName }}) GetTableName() string {
	return repo.table.Name()
}

// HasArg HasKeyのペアを返す
func (repo *{{ .RepositoryStructName }}) hashPair(subject *{{ .StructName }}) (string, string) {
	return "'{{ .HashKeyFieldTagName }}'", subject.{{ .HashKeyFieldName }}
}

{{- if eq .EnableIndexes true }}
// saveIndexes 拡張フィルタを保存する
func (repo *{{ .RepositoryStructName }}) saveIndexes(subjects ...*{{ .StructName }}) error {
	for _, subject := range subjects {
		idx := xian.NewIndexes({{ .StructName }}IndexesConfig)
{{- range $fi := .FieldInfos }}
{{- $PrefixIsSlice := HasPrefixSlice $fi.FieldType}}
{{- range $idx := $fi.Indexes }}
{{- if or (eq $fi.FieldType "bool") (eq $fi.FieldType "int" ) (eq $fi.FieldType "int64" ) (eq $fi.FieldType "float64" ) }}
		idx.{{ $idx.Method }}({{ $idx.ConstName }}, subject.{{ $fi.Field }})
{{- else if eq $fi.FieldType "string" }}
{{- if eq $idx.Method "AddPrefix" }}
		idx.{{ $idx.Method }}es({{ $idx.ConstName }}, subject.{{ $fi.Field }})
{{- else }}
		idx.{{ $idx.Method }}({{ $idx.ConstName }}, subject.{{ $fi.Field }})
{{- end }}
{{- else if eq $fi.FieldType "time.Time" }}
		idx.{{ $idx.Method }}({{ $idx.ConstName }}, subject.{{ $fi.Field }}.Unix())
{{- else if eq $PrefixIsSlice true }}
		idx.{{ $idx.Method }}({{ $idx.ConstName }}, subject.{{ $fi.Field }})
{{- end }}
{{- end }}
{{- end }}
		built, err := idx.Build()
		if err != nil {
			return err
		}
		subject.Indexes = built
	}

	return nil
}

// {{ .StructName }}IndexesConfig {{ .StructName }}用のIndexesConfigを設定する
var {{ .StructName }}IndexesConfig = &xian.Config{
	// IgnoreCase Case insensitive
	// └── 大文字小文字を区別しない
	IgnoreCase:         true,
	// SaveNoFiltersIndex 検索時にフィルタを設定しない場合、この拡張フィルタなし検索用インデックスのEquality Filterが自動で適用される
	// ├── falseで、拡張フィルタのあり・なしの両パターンの検索がある場合、カスタムインデックスを両パターン分用意しておく必要がある
	// └── trueにしておくことでカスタムインデックスを半分に節約することができる
	SaveNoFiltersIndex: true,
}
{{- end }}

// Get 処理中の {{ .StructName }} の取得処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) Get(ctx context.Context, {{ .HashKeyValueName }} {{ .HashKeyFieldType }}{{ RangeKeyArgCheck }}) (*{{ .StructName }}, error) {
	subject := new({{ .StructName }})
	if err := repo.table.Get("'{{ .HashKeyFieldName }}'", {{ .HashKeyValueName }}){{ RangeKeyValueCheckForGet }}.OneWithContext(ctx, &subject); err != nil {
		return nil, err
	}
	return subject, nil
}

// Insert 処理中の {{ .StructName }} の登録処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) Insert(ctx context.Context, subject *{{ .StructName }}) error {
	return repo.table.Put(subject).RunWithContext(ctx)
}

// Update 処理中の {{ .StructName }} の更新処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) Update(ctx context.Context, subject *{{ .StructName }}) (err error) {
	old, err := repo.Get(ctx, subject.ID{{ RangeKeyDelivery }})
	if err != nil {
		return err
	}
	if reflect.DeepEqual(old, subject) {
		return xerrors.Errorf("cannot update because there is no difference. Hash: %v", subject.ID)
	}
	q := repo.table.Update(repo.hashPair(subject))
	bv := reflect.Indirect(reflect.ValueOf(old))
	av := reflect.Indirect(reflect.ValueOf(subject))
	for n := 0; n < av.NumField(); n++ {
		f := av.Type().Field(n)
		bf := bv.Index(n)
		af := bv.Index(n)
		path := fmt.Sprintf("'%s'", f.Name)
		if bf.Interface() != af.Interface() {
			switch af.Kind() {
			case reflect.Array, reflect.Slice:
				q = q.SetSet(path, af.Interface())
			default:
				q = q.Set(path, af.Interface())
			}
		}
	}
	return q.RunWithContext(ctx)
}

// ForceUpdate 処理中の {{ .StructName }} の更新処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) ForceUpdate(ctx context.Context, subject *{{ .StructName }}) error {
	u := repo.table.Update(repo.hashPair(subject)).
{{- range $i, $fi := .FieldInfos }}
		Set("{{ $fi.DynamoTag }}", subject.{{ $fi.Field }}){{ HasColon $i $.FieldInfos }}
{{- end }}
	return u.RunWithContext(ctx)
}

// Delete 処理中の {{ .StructName }} の削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) Delete(ctx context.Context, subject *{{ .StructName }}) error {
	return repo.table.Delete(repo.hashPair(subject)){{ RangeKeyValueCheckForDelete }}.RunWithContext(ctx)
}

// DeleteBy{{ .HashKeyFieldName }} 処理中の {{ .StructName }} の{{ .HashKeyFieldName }}から削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) DeleteBy{{ FuncNameByValue }}(ctx context.Context, {{ .HashKeyValueName }} {{ .HashKeyFieldType }}{{ RangeKeyArgCheck }}) error {
	return repo.table.Delete("'{{ .HashKeyFieldName }}'", {{ .HashKeyValueName }}){{ RangeKeyValueCheckForDeletePair }}.RunWithContext(ctx)
}

// GetMulti 処理中の {{ .StructName }} の一括取得処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) GetMulti(ctx context.Context, {{ RangeKeyArgCheckPairs }}) (subjects []*{{ .StructName }}, err error) {
	for {{ RangeKeyForTerms }} {
		subject, err :=  repo.Get(ctx, {{ RangeKeyForValue }})
		if err != nil {
			return nil,  err
		}
		subjects = append(subjects, subject)
	}
	return
}

// InsertMulti 処理中の {{ .StructName }} の一括挿入処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) InsertMulti(ctx context.Context, subjects []*{{ .StructName }}) error {
	tx := repo.db.WriteTx()
	for _, subject := range subjects {
		tx.Put(repo.table.Put(subject))
	}
	return tx.RunWithContext(ctx)
}

// UpdateMulti 処理中の {{ .StructName }} の一括更新処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) UpdateMulti(ctx context.Context, subjects []*{{ .StructName }}) error {
	tx := repo.db.WriteTx()
	for _, subject := range subjects {
		u := repo.table.Update(repo.hashPair(subject)).
{{- if ne .RangeKeyFieldName "" }}
			Range("'{{ .RangeKeyFieldTagName }}'", subject.{{ .RangeKeyFieldName }}).
{{- end }}
{{- range $i, $fi := .FieldInfos }}
			Set("'{{ $fi.DynamoTag }}'", subject.{{ $fi.Field }}){{ HasColon $i $.FieldInfos }}
{{- end }}
		tx.Update(u)
	}
	return tx.RunWithContext(ctx)
}

// DeleteMulti 処理中の {{ .StructName }} の一括削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) DeleteMulti(ctx context.Context, subjects []*{{ .StructName }}) error {
	tx := repo.db.WriteTx()
	for _, subject := range subjects {
		tx.Delete(repo.table.Delete(repo.hashPair(subject)){{ RangeKeyValueCheckForDelete }})
	}
	return tx.RunWithContext(ctx)
}

// DeleteMultiBy{{ .HashKeyFieldName }}s 処理中の {{ .StructName }} の{{ .HashKeyFieldName }}群を元に一括削除処理一切の責任を持ち、これを行う
func (repo *{{ .RepositoryStructName }}) DeleteMultiBy{{ FuncNameByValue }}s(ctx context.Context, {{ RangeKeyArgCheckPairs }}) error {
	tx := repo.db.WriteTx()
	for {{ RangeKeyForTerms }} {
		tx.Delete(repo.table.Delete{{ RangeKeyForDeleteMultiByPairs }})
	}
	return tx.RunWithContext(ctx)
}
